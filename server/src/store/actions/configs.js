const Configs = require('../../models/Configs')

const actions = {
  async setConfigs ({ commit }) {
    return Configs.getAll((err, results) => {
      if (err) return log.error(err)

      results.forEach(val => commit('updateConfig', val.toObject()))
    })
  },

  updateConfig ({ state, commit, dispatch }, config) {
    let configsCount = Object.keys(state.configs).length
    commit('updateConfig', config)

    io.emit('SOCKET_CONFIGS_UPDATE_ONE', state.configs[config.name])

    if (configsCount !== Object.keys(state.configs).length) {
      dispatch('updateCharts')
    }
  },

  updateConfigDb ({ state, commit, dispatch }, data) {
    Configs.getOne(data.name, (err, config) => {
      if (err) return log.error(err)

      if (!config) {
        config = new Configs(data)
      } else {
        Object.keys(data).forEach(key => {
          if (!key.startsWith('_')) {
            config[key] = data[key]
            config.markModified(key)
          }
        })
      }

      config.save(err => {
        if (err) return log.error(err)

        $store.dispatch('updateConfig', config.toObject())
      })
    })
  },

  createEmptyConfig ({ state, dispatch }, emptyConfig) {
    if (!state.configs[emptyConfig.name]) {
      let config = new Configs(emptyConfig)
      config.type = 'AUTOGENERATED'

      config.save(err => {
        if (err) return log.error(err)

        dispatch('updateConfig', config.toObject())
      })
    }
  },

  updateConfigSorting ({ state, commit, dispatch }, newConfig) {
    Configs.getOne(newConfig.name, (err, config) => {
      if (err) return log.error(err)

      config.sortBy = newConfig.sortBy
      config.save(err => {
        if (err) return log.error(err)

        dispatch('updateConfig', config.toObject())
      })
    })
  },

  addStage ({ state, dispatch }, configWithStage) {
    let currentConfig = state.configs[configWithStage.name]
    if (!currentConfig) {
      dispatch('createEmptyConfig', configWithStage)
    } else if (!currentConfig.stages.includes(configWithStage.stages[0])) {
      Configs.getOne(configWithStage.name, (err, config) => {
        if (err) return log.error(err)

        config.stages.push(configWithStage.stages[0])
        config.markModified('stages')
        config.save(err => {
          if (err) return log.error(err)

          dispatch('updateConfig', config.toObject())
        })
      })
    }
  },

  deleteConfig ({ state, commit }, name) {
    commit('deleteConfig', name)

    if (Object.keys(state.configs).length === 0) {
      commit('deleteChart', 'Processes')
    }

    io.emit('SOCKET_CONFIGS_DELETE', { name: name })
  },

  recalcSorting ({ state, dispatch }, config) {
    const threshold = 0.999999999999
    const step = 2048
    const maxValue = 999999999

    if (Math.abs(config.sortBy) % 1 >= threshold || Math.abs(config.sortBy) >= maxValue) {
      Configs.getAll((err, results) => {
        if (err) return log.error(err)

        let idx = 0
        results.forEach(val => {
          let doUpdate = false
          let newSorting = step * idx
          idx++

          if (val.disabled === true && val.sortBy !== maxValue) {
            val.sortBy = maxValue
            doUpdate = true
          } else if (val.disabled !== true && val.sortBy !== newSorting) {
            val.sortBy = newSorting
            doUpdate = true
          }

          if (doUpdate) {
            val.save(err => {
              if (err) return log.error(err)

              dispatch('updateConfig', val.toObject())
            })
          }
        })
      })
    }
  }
}

module.exports = actions

const Configs = require('../../models/Configs')

const actions = {
  async setConfigs ({ commit }) {
    return Configs.getAll((err, results) => {
      if (err) return log.error(err)

      results.forEach(val => commit('updateConfig', val.toObject()))
    })
  },

  updateConfig ({ state, commit, dispatch }, config) {
    let configsCount = Object.keys(state.configs).length
    commit('updateConfig', config)

    io.emit('SOCKET_CONFIGS_UPDATE', state.configs[config.name])

    if (configsCount !== Object.keys(state.configs).length) {
      dispatch('updateCharts')
    }
  },

  createEmptyConfig ({ state, dispatch }, emptyConfig) {
    if (!state.configs[emptyConfig.name]) {
      let config = new Configs(emptyConfig)
      config.type = 'AUTOGENERATED'

      config.save(err => {
        if (err) return log.error(err)

        $store.dispatch('updateConfig', config.toObject())
      })
    }
  },

  addStage ({ state, dispatch }, configWithStage) {
    let currentConfig = state.configs[configWithStage.name]
    if (!currentConfig) {
      dispatch('createEmptyConfig', configWithStage)
    } else if (!currentConfig.stages.includes(configWithStage.stages[0])) {
      Configs.getOne(configWithStage.name, (err, config) => {
        if (err) return log.error(err)

        config.stages.push(configWithStage.stages[0])
        config.markModified('stages')
        config.save(err => {
          if (err) return log.error(err)

          $store.dispatch('updateConfig', config.toObject())
        })
      })
    }
  },

  deleteConfig ({ state, commit }, name) {
    commit('deleteConfig', name)

    if (Object.keys(state.configs).length === 0) {
      commit('deleteChart', 'Processes')
    }

    io.emit('SOCKET_CONFIGS_DELETE', { name: name })
  }
}

module.exports = actions
